const fillWeight = 5
const roughness = 1
const strokeWidth = 1.4
const fontDef = "20px xkcd script"

const { createCanvas, loadImage } = require('canvas')
require('canvas-5-polyfill')
const fs = require('fs')
const util = require("util")
const _ = require("underscore")._

self = this
self.document = {}
self.document.currentScript = {}
window = process
eval(fs.readFileSync("rough.js", 'utf-8'))
const xpath = require('xpath');
const dom = require('xmldom').DOMParser;
const select = xpath.useNamespaces({"x": "http://www.w3.org/2000/svg"});
const serializer = require('xmldom').XMLSerializer
const s = new serializer()

Math.seed = (s) =>
    () => { s = Math.sin(s) * 10000; return s - Math.floor(s); };

const SVGO = require("svgo")
const svgo = new SVGO({
        js2svg: {
            pretty: true
        },
        plugins: [{
             cleanupAttrs: true,
        }, { removeDoctype: true,
        }, { removeXMLProcInst: true,
        }, { removeComments: true,
        }, { removeMetadata: true,
        }, { removeTitle: true,
        }, { removeDesc: true,
        }, { removeUselessDefs: true,
        }, { removeEditorsNSData: true,
        }, { removeEmptyAttrs: true,
        }, { removeHiddenElems: true,
        }, { removeEmptyText: true,
        }, { removeEmptyContainers: true,
        }, { removeViewBox: true,
        }, { cleanUpEnableBackground: true,
        }, { minifyStyles: true,
        }, { convertStyleToAttrs: true,
        }, { convertColors: true,
        }, { convertPathData: true,
        }, { convertTransform: true,
        }, { removeUnknownsAndDefaults: false,
        }, { removeNonInheritableGroupAttrs: true,
        }, { removeUselessStrokeAndFill: true,
        }, { removeUnusedNS: true,
        }, { cleanupIDs: false,
        }, { cleanupNumericValues: true,
        }, { moveElemsAttrsToGroup: false,
        }, { moveGroupAttrsToElems: true,
        }, { collapseGroups: true,
        }, { removeRasterImages: false,
        }, { mergePaths: true,
        }, { convertShapeToPath: true,
        }, { sortAttrs: true,
        }, { transformsWithOnePath: true,
        }, { removeDimensions: false,
        },]
      });
        // removeAttrs: {attrs: '(stroke|fill)'},

async function convertSvgToSketch(svg, seed, id) {
    if (svg[0] != "<") {
        return ""
    }
    seed = seed || 42
    Math.random = Math.seed(seed)
    id = id || undefined

    const svg_optimized = await svgo.optimize(svg);
    const doc = new dom().parseFromString(svg_optimized.data, "svg+xml");
    //const doc = new dom().parseFromString(svg, "svg+xml");

    // roughjs assumes pt, rest of the world px :-O
    const width = parseInt(.75 * select("/x:svg/@width", doc)[0].value)
    const height = parseInt(.75 * select("/x:svg/@height", doc)[0].value)

    // init canvas
    const canvas = createCanvas(width, height, "svg")
    const rc = rough.canvas(canvas, {async: false,
                                     options: {roughness: roughness, strokeWidth: strokeWidth},
                                     noWorker: true})

    // plot
    const ctx = canvas.getContext("2d")
    // canvas-5-polyfill patches CanvasRenderingContext2D.prototype
    // lets give it one
    global.CanvasRenderingContext2D = {};
    global.CanvasRenderingContext2D.prototype = ctx;

    ctx.antialias = "gray"

    //const nodes = doc.getElementsByTagName("path");
    // select("//x:g/x:path", doc);
    //for (var i=0; i<nodes.length; i++) {
        //let e = nodes[i]
    const nodes = select("//x:g/x:path", doc)
    for (var i=0; i<nodes.length; i++) {
        let d = nodes[i].attributes.getNamedItem("d")

        // "fill", "fillStyle", "fillWeight",
        // "hachureAngle", "hachureGap",
        // "stroke", "strokeWidth",
        // "bowing", "roughness", "simplification"
        function collectAttrs(node, attrs) {
            attrs = attrs || {}
            if (node.tagName === "svg") {
                return attrs
            }
            _.each(node.attributes, (a) => {
                if (a.name != "id") {
                    if (!(a.name in attrs)) {
                        if (a.value !== "none") {
                            //console.log(a.name, ":", a.value)
                            attrs[a.name] = a.value
                        }
                    }
                }
            })
            return collectAttrs(node.parentNode, attrs)
        }
        let options = collectAttrs(nodes[i])
        await rc.path(d.value, options)
    };

    ctx.font = fontDef
    _.each(select("//x:g/x:text", doc), (te) => {
        var x = select("./@x", te)[0].value
        var y = select("./@y", te)[0].value
        var fill = select("./@fill", te)[0]
        if (fill) {
            ctx.fillStyle = fill.value
        }
        var text = te.firstChild.data.trim()
        ctx.fillText(text, parseInt(x), parseInt(y), width - x)
    })

    // copy non-rough elements, like markers...
    const defs = s.serializeToString(select("/x:svg/x:defs", doc)[0])
    const markers = s.serializeToString(select("//x:g[@id='lines']", doc)[0])
    var result = canvas.toBuffer().toString()
    result = result.replace("</svg>", defs + markers + "</svg>")
    const result_doc = new dom().parseFromString(result, "svg+xml");
    _.each(select("//x:svg/x:g", result_doc), (gn) => {
        gn.setAttribute("transform", "scale(0.75)")
    })
    if (id != undefined) {
        result_doc.documentElement.setAttribute("id", id)
    }
    return await svgo.optimize(s.serializeToString(result_doc))
    //return await svgo.optimize(canvas.toBuffer().toString())
    //return {data: s.serializeToString(result_doc)}
}

async function convertAsciiToSvg(text) {
    var exec = require('child_process').execSync
    let svg = exec('a2s -i- -o-', {input: text}).toString()
    return await svgo.optimize(svg);
    // return {data: svg}
}


const express = require('express');
const app = express();
const bodyParser = require('body-parser')
app.use(bodyParser.text({ inflate: true, limit: '10mb', type: 'text/svg+xml' }));
app.use(bodyParser.text({ inflate: true, limit: '10mb', type: 'text/plain' }));
app.use(bodyParser.text({ inflate: true, limit: '10mb', type: 'application/x-www-form-urlencoded' }));

app.post('/s2sketch', function(req, res){
    try {
        convertSvgToSketch(req.body, req.query.seed, req.query.id).then((result) => {
            res.set('Content-Type', 'text/svg+xml')
            res.status(200).send(result.data)
        })
    } catch(error) {
        console.log(error)
        res.status(500).send(error)
    }
});

app.post('/a2svg', function(req, res){
    convertAsciiToSvg(req.body).then((result) => {
        res.set('Content-Type', 'text/svg+xml')
        res.status(200).send(result.data)
    })
});

app.post('/a2sketch', function(req, res){
    if (req._body) {
        var svg = convertAsciiToSvg(req.body)
        var sketch = convertSvgToSketch(svg, req.query.seed)
        res.set('Content-Type', 'text/svg+xml')
        res.status(200).send(sketch)
    } else {
        res.status(400).end("empty body?!")
    }
});

process.on('SIGINT', function() {
    console.log("Caught interrupt signal");
    process.exit();
});

port = 22753;
app.listen(port);
console.log('Listening at http://localhost:' + port)
